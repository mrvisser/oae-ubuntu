{
  "name": "passport-saml",
  "version": "0.0.4",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/bergie/passport-saml/raw/master/LICENSE"
    }
  ],
  "keywords": [
    "saml",
    "adfs",
    "sso",
    "shibboleth"
  ],
  "description": "SAML 2.0 authentication strategy for Passport",
  "author": {
    "name": "Henri Bergius",
    "email": "henri.bergius@iki.fi",
    "url": "http://bergie.iki.fi"
  },
  "contributors": [
    {
      "name": "Michael Bosworth"
    }
  ],
  "main": "./lib/passport-saml",
  "dependencies": {
    "passport": "0.1.x",
    "lru-cache": "2.2.x",
    "xml2js": "0.2.0",
    "xml-crypto": "0.0.x",
    "xmldom": "0.1.x"
  },
  "devDependencies": {
    "express": "2.5.x",
    "ejs": "0.7.x",
    "jshint": "*"
  },
  "engines": {
    "node": ">= 0.6.0"
  },
  "readme": "Passport-SAML\n=============\n\nThis is a [SAML 2.0](http://en.wikipedia.org/wiki/SAML_2.0) authentication provider for [Passport](http://passportjs.org/), the Node.js authentication library.\n\nThe code was originally based on Michael Bosworth's [express-saml](https://github.com/bozzltron/express-saml) library.\n\nPassport-SAML has been tested to work with both [SimpleSAMLphp](http://simplesamlphp.org/) based Identity Providers, and with [Active Directory Federation Services](http://en.wikipedia.org/wiki/Active_Directory_Federation_Services).\n\n## Installation\n\n    $ npm install passport-saml\n\n## Usage\n\n### Configure strategy\n\nThis example utilizes the [Feide OpenIdp identity provider](https://openidp.feide.no/). You need an account there to log in with this. You also need to [register your site](https://openidp.feide.no/simplesaml/module.php/metaedit/index.php) as a service provider.\n\nThe SAML identity provider will redirect you to the URL provided by the `path` configuration.\n\n```javascript\npassport.use(new SamlStrategy(\n  {\n    path: '/login/callback',\n    entryPoint: 'https://openidp.feide.no/simplesaml/saml2/idp/SSOService.php',\n    issuer: 'passport-saml'\n  },\n  function(profile, done) {\n    findByEmail(profile.email, function(err, user) {\n      if (err) {\n        return done(err);\n      }\n      return done(null, user);\n    });\n  })\n));\n```\n\n### Provide the authentication callback\n\nYou need to provide a route corresponding to the `path` configuration parameter given to the strategy:\n\n```javascript\napp.post('/login/callback',\n  passport.authenticate('saml', { failureRedirect: '/', failureFlash: true }),\n  function(req, res) {\n    res.redirect('/');\n  }\n);\n```\n\n### Authenticate requests\n\nUse `passport.authenticate()`, specifying `saml` as the strategy:\n\n```javascript\napp.get('/login',\n  passport.authenticate('saml', { failureRedirect: '/', failureFlash: true }),\n  function(req, res) {\n    res.redirect('/');\n  }\n);\n```\n\n## Security and signatures\n\nPassport-SAML uses the HTTP Redirect Binding for its `AuthnRequest`s, and expects to receive the messages back via the HTTP POST binding.\n\nAuthentication requests sent by Passport-SAML can be signed using RSA-SHA1. To sign them you need to provide a private key in the PEM format via the `privateCert` configuration key. For example:\n\n```javascript\n    privateCert: fs.readFileSync('./cert.pem', 'utf-8')\n```\n\nIt is a good idea to validate the incoming SAML Responses. For this, you can provide the Identity Provider's certificate using the `cert` confguration key:\n\n```javascript\n    cert: 'MIICizCCAfQCCQCY8tKaMc0BMjANBgkqh ... W=='\n```\n\n## Usage with Active Directory Federation Services\n\nHere is a configuration that has been proven to work with ADFS:\n\n```javascript\n  {\n    entryPoint: 'https://ad.example.net/adfs/ls/',\n    issuer: 'https://your-app.example.net/login/callback',\n    callbackUrl: 'https://your-app.example.net/login/callback',\n    cert: 'MIICizCCAfQCCQCY8tKaMc0BMjANBgkqh ... W==',\n    identifierFormat: null\n  }\n```\n\nPlease note that ADFS needs to have a trust established to your service in order for this to work.\n\n\n## Usage with Shibboleth\n\nWarning: Running with this configuration will *NOT* bring you on feature parity with the full-fledged Shibboleth SP and only supports the most basic SSO operations.\n\nYou will need to have a Java Runtime present as Java is used to parse incoming encrypted requests.\n\nIt assumes you use HTTP-REDIRECT to initiate the shib process with the IdP and expects an HTTP-POST as answer. This means you'll need 2 routes. One for the outgoing request and one for the incoming request, similar as the [OAuth passport routes](http://passportjs.org/guide/oauth/).\n\nThe following configuration has been tested with the [Test Shibboleth IdP](http://www.testshib.org).\n\n```\n{\n// Wether we'll be talking to shibboleth\n'isShibboleth': true,\n\n// The URL where the IdP should redirect the user to.\n'callbackUrl': 'https://oae.cam.ac.uk/api/auth/shibboleth/callback',\n\n// The URL where we should redirect the user to.\n'entryPoint': 'https://idp.testshib.org/idp/profile/SAML2/Redirect/SSO',\n\n// The entityID that we used to register our SP\n'issuer': 'https://oae.cam.ac.uk/shibboleth',\n\n// The public certificate of the TestShib IdP\n// Find the full one at https://www.testshib.org/metadata/testshib-providers.xml\n'cert': 'MIIEDjCCAvagAwIBAgIBADANBgkqhkiG9w0BAQUFADBnMQswCQYDVQQ...nl+ev0peYzxFyF5sQA==',\n\n// The path to the parser jar.\n// The parser will be used to decrypt anything that the IdP sends us.\n// See https://github.com/sakaiproject/SAMLParser\n'converter': '/path/to/the/parser.jar',\n\n// Your public certificate\n'publicCert': 'MIICizCCAfQCCQCY8tKaMc0BMjANBgkqh ... W==',\n\n// The subject name you used in your certificate (CN)\n'publicCertSubjectName': 'oae.cam.ac.uk',\n\n// Your private certificate\n'privateCert': 'MIvjVG3NaSG6 ... 32ea+',\n'identifierFormat': null\n\n// It would not be un-wise to pass in an implementation of the AntiReplayStore if you're\n// running in a cluster as you might be vulnerable to replay attacks otherwise.\n}\n```\n\nYou will have to register your Node application as a SP with the Shibboleth IdP. This usually involves passing on an XML file that contains all the metadata for your SP. To facilitate this process, the SamlStrategy exposes a `getShibbolethMetadata` method which returns the XML as a string. You could add a third route which dumps this info.\n\n```javascript\nvar samlStrategy = new SamlStrategy({ /* .. */ });\n// ..\napp.get('/shibboleth/metadata', function(req, res) {\n    res.send(200, samlStrategy.getShibbolethMetadata());\n});\n```\n\n\n## Anti Replay\n\nTo thwart anti-replay attacks, some state is kept to check if a returning opensaml response was initiated by us.\n\nWarning: The default implementation uses local in-memory storage and will *NOT* work in a cluster.\n\nThe following is an implementation of the anti replay store that can be used in a cluster and can be passed in as an option to the strategy. It uses Redis as a canonical source to store data in. (This obviously assumes that all app nodes are connected to the same Redis instance.)\n\n```\n'antiReplayStore': {\n    // callback is of the form callback(error, value);\n    'get': function(id, callback) {\n        var key = util.format('shibboleth:%s', id);\n        Redis.getClient().get(key, callback);\n    },\n\n    // callback is of the form callback(error);\n    'set': function(id, data, callback) {\n        var key = util.format('shibboleth:%s', id);\n        Redis.getClient().setex(key, 5 * 60, data, callback);\n    },\n\n    // callback is of the form callback(error);\n    'del': function(id, callback) {\n        var key = util.format('shibboleth:%s', id);\n        Redis.getClient().del(key, callback);\n    }\n}\n```",
  "readmeFilename": "README.md",
  "_id": "passport-saml@0.0.4",
  "dist": {
    "shasum": "bd2de2249766104021a3514ccd4a476d445a0e53"
  },
  "_resolved": "git://github.com/simong/passport-saml#c43394ac00cd769f52b646d8bc7505e5d23c25b4",
  "_from": "passport-saml@git://github.com/simong/passport-saml#c43394ac00cd769f52b646d8bc7505e5d23c25b4"
}
